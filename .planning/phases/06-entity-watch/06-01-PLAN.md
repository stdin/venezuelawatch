---
phase: 06-entity-watch
plan: 01
type: execute
---

<objective>
Create Entity and EntityMention models with RapidFuzz-based deduplication service for tracking people, companies, and governments mentioned in events.

Purpose: Establish database schema and fuzzy matching infrastructure to normalize and aggregate entity mentions across events
Output: Working Entity model, EntityMention linking table, EntityService with fuzzy name matching
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-entity-watch/06-CONTEXT.md
@.planning/phases/06-entity-watch/DISCOVERY.md
@backend/core/models.py

**From Phase 5:**
- Dashboard with event feed, filtering, risk visualization
- Events have entities ArrayField (populated by LLM analysis)

**From Phase 4:**
- Risk scoring system with sanctions screening
- LLM analysis extracting structured entities from events

**From DISCOVERY.md:**
- Use RapidFuzz for fuzzy name matching (10x faster than FuzzyWuzzy)
- Jaro-Winkler similarity algorithm best for name matching
- Threshold 0.85 (85% match) for automatic deduplication
- Redis Sorted Sets for trending leaderboard (already have Redis)
- Entity model with canonical_name, aliases, entity_type, mention_count
- EntityMention through table linking events to normalized entities

**Key constraints:**
- Events already have `entities` ArrayField with raw extracted names
- Need fuzzy matching to normalize: "Nicol치s Maduro" = "N. Maduro" = "President Maduro"
- Trending algorithm uses time-decay (7-day half-life) stored in Redis
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install RapidFuzz and create Entity/EntityMention models</name>
  <files>backend/requirements.txt, backend/core/models.py</files>
  <action>
Add rapidfuzz>=3.0.0 to requirements.txt.

In backend/core/models.py, add two new models AFTER the existing Event and SanctionsMatch models:

1. **Entity model** with fields:
   - id: UUIDField primary key with uuid4 default
   - canonical_name: CharField(200, unique=True, db_index=True) - normalized entity name
   - aliases: ArrayField(CharField(200), default=list) - known name variations
   - entity_type: CharField(20) with choices: PERSON, ORGANIZATION, GOVERNMENT, LOCATION
   - mention_count: IntegerField(default=0, db_index=True) - total mentions across events
   - first_seen: DateTimeField(auto_now_add=True)
   - last_seen: DateTimeField(auto_now=True)
   - metadata: JSONField(blank=True, null=True) - additional info (roles, descriptions)
   - created_at, updated_at: DateTimeField auto timestamps
   - Meta: db_table='entities', ordering=['-mention_count', '-last_seen']

2. **EntityMention model** (many-to-many through table):
   - id: UUIDField primary key
   - entity: ForeignKey(Entity, CASCADE, related_name='mentions')
   - event: ForeignKey(Event, CASCADE, related_name='entity_mentions')
   - raw_name: CharField(200) - original name extracted from event
   - match_score: FloatField - fuzzy match confidence (0.0-1.0)
   - relevance: FloatField(null=True) - LLM relevance score if available
   - mentioned_at: DateTimeField(db_index=True) - denormalized from event.timestamp for trending
   - created_at: DateTimeField(auto_now_add=True)
   - Meta: db_table='entity_mentions', unique_together=[('entity', 'event', 'raw_name')], indexes on ['-mentioned_at'], ['entity', '-mentioned_at']

Use PostgreSQL-specific features: ArrayField, JSONField, GIN indexes where appropriate (ArrayField for aliases).
  </action>
  <verify>python backend/manage.py makemigrations shows new 0003_entity_entitymention migration</verify>
  <done>Models defined, migration file created, no syntax errors</done>
</task>

<task type="auto">
  <name>Task 2: Create EntityService with RapidFuzz fuzzy matching</name>
  <files>backend/data_pipeline/services/entity_service.py</files>
  <action>
Create backend/data_pipeline/services/entity_service.py with EntityService class containing:

1. **find_or_create_entity(raw_name: str, entity_type: str, metadata: dict = None) -> Tuple[Entity, bool, float]**
   - Use RapidFuzz JaroWinkler.similarity to match against existing Entity.canonical_name and aliases
   - Search entities of same type only (don't match person to organization)
   - Use process.extractOne with threshold=0.85 (85% match)
   - Use utils.default_process for case-insensitive, whitespace-normalized matching
   - If match found: Return (matched_entity, False, match_score), add raw_name to aliases if not present
   - If no match: Create new Entity with canonical_name=raw_name, entity_type=entity_type
   - Return (entity, created, match_score)

2. **link_entity_to_event(entity: Entity, event: Event, raw_name: str, match_score: float, relevance: float = None) -> EntityMention**
   - Create EntityMention with entity, event, raw_name, match_score, relevance
   - Use mentioned_at = event.timestamp (denormalized for trending queries)
   - Handle unique constraint (get_or_create pattern)
   - Increment entity.mention_count, update entity.last_seen
   - Return EntityMention instance

3. **batch_deduplicate_entities(entity_type: str = None, threshold: float = 0.90) -> int**
   - Find duplicate entities using pairwise fuzzy matching (higher threshold 0.90 for batch)
   - Merge duplicates: move all EntityMentions to canonical entity, combine aliases, sum mention_counts
   - Delete duplicate entities
   - Return count of merged entities
   - This is for cleanup/maintenance, not real-time processing

Import: from rapidfuzz import process, utils; from rapidfuzz.distance import JaroWinkler; from django.db import transaction; from typing import Tuple, Optional

Use @transaction.atomic for operations that modify multiple records (linking, deduplication).
  </action>
  <verify>python backend/manage.py check passes, import entity_service succeeds</verify>
  <done>EntityService with 3 methods (find_or_create, link, batch_deduplicate), uses RapidFuzz JaroWinkler, threshold 0.85 for real-time matching</done>
</task>

<task type="auto">
  <name>Task 3: Apply migrations and test fuzzy matching</name>
  <files>N/A</files>
  <action>
Run python backend/manage.py makemigrations to generate migration.
Run python backend/manage.py migrate to apply Entity and EntityMention tables.

Test EntityService fuzzy matching in Django shell:
```python
from data_pipeline.services.entity_service import EntityService
from core.models import Entity

# Test creation
entity1, created, score = EntityService.find_or_create_entity("Nicol치s Maduro", "PERSON")
print(f"Created: {created}, Score: {score}, Name: {entity1.canonical_name}")

# Test fuzzy matching (should match "Nicol치s Maduro")
entity2, created, score = EntityService.find_or_create_entity("N. Maduro", "PERSON")
print(f"Created: {created}, Score: {score}, Matched: {entity2.canonical_name}")
assert entity1.id == entity2.id, "Should match same entity"
assert score >= 0.85, "Match score should be high"

# Test non-match (different person)
entity3, created, score = EntityService.find_or_create_entity("Joe Biden", "PERSON")
print(f"Created: {created}, Score: {score}, Name: {entity3.canonical_name}")
assert entity3.id != entity1.id, "Should be different entity"
```

Confirm fuzzy matching works correctly (variations match, different names don't).
  </action>
  <verify>Migrations applied, Entity and EntityMention tables exist in database, fuzzy matching test passes</verify>
  <done>Database schema created, EntityService fuzzy matching verified with test cases</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Entity and EntityMention models defined in core/models.py
- [ ] Migration 0003_entity_entitymention created and applied
- [ ] EntityService with find_or_create_entity, link_entity_to_event, batch_deduplicate_entities
- [ ] RapidFuzz JaroWinkler fuzzy matching working (threshold 0.85)
- [ ] Manual test in Django shell confirms name variations match correctly
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Fuzzy matching normalizes entity name variations (e.g., "Nicol치s Maduro" = "N. Maduro")
- Database schema ready for entity extraction pipeline
  </success_criteria>

<output>
After completion, create `.planning/phases/06-entity-watch/06-01-SUMMARY.md`:

# Phase 6 Plan 1: Entity Models & Fuzzy Matching Service Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description
- `path/to/another.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 06-02-PLAN.md (Entity Extraction Celery Task)
</output>
