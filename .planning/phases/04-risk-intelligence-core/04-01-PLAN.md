---
phase: 04-risk-intelligence-core
plan: 01
type: execute
---

<objective>
Integrate sanctions screening to detect when events mention sanctioned entities.

Purpose: Enable compliance checking and automatic risk elevation for events involving sanctioned individuals or organizations.
Output: Sanctions screening service with OpenSanctions/OFAC API integration, SanctionsMatch model for tracking matches, daily refresh task.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-risk-intelligence-core/04-RESEARCH.md
@backend/core/models.py
@backend/data_pipeline/services/llm_intelligence.py
@backend/data_pipeline/tasks/intelligence_tasks.py
@backend/venezuelawatch/settings.py
@backend/.env.example

**Tech stack available (from prior phases):**
- Django 5.2, django-ninja for REST API
- Celery + Redis for async tasks and scheduling
- TimescaleDB/PostgreSQL for database
- LiteLLM with Claude 4.5 for intelligence analysis
- GCP Secret Manager for API credentials
- Event model with llm_analysis JSONField containing extracted entities

**Established patterns:**
- Secret Manager integration for API credentials (Phase 3)
- Celery BaseIngestionTask for common task patterns (Phase 3)
- Entity extraction in llm_analysis['entities']['people'] and ['organizations'] (existing)
- Daily scheduled tasks with Celery Beat (Phase 3)

**Constraining decisions:**
- OpenSanctions recommended over custom fuzzy matching (from RESEARCH: "don't hand-roll sanctions matching")
- Fuzzy match threshold 0.6-0.7 for name variations (accents, aliases, transliterations)
- Store sanctions_checked_at timestamp to track data freshness
- Free OFAC API acceptable alternative if OpenSanctions cost prohibitive

**Research findings:**
- OpenSanctions: 321 sources, 2.19M entities, fuzzy matching API
- Common pitfall: Sanctions false negatives (Nicolas vs Nicolás Maduro Moros)
- Common pitfall: Sanctions data staleness (daily refresh required)
- Pattern: Binary sanctions scoring (0.0 = clean, 1.0 = sanctioned) with threshold 0.7
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure sanctions API credentials and create SanctionsMatch model</name>
  <files>backend/.env.example, backend/venezuelawatch/settings.py, backend/core/models.py, backend/core/migrations/000X_sanctionsmatch.py, backend/requirements.txt</files>
  <action>
    1. Add OpenSanctions/OFAC API configuration to settings:
       - OPENSANCTIONS_API_KEY from environment/Secret Manager (prefer free OFAC API if OpenSanctions cost unclear)
       - OPENSANCTIONS_BASE_URL = 'https://api.opensanctions.org' (or use treasury.gov OFAC API)

    2. Update .env.example with API key placeholder and documentation link

    3. Create SanctionsMatch model in backend/core/models.py:
       ```python
       class SanctionsMatch(models.Model):
           id = models.UUIDField(primary_key=True, default=uuid.uuid4)
           event = models.ForeignKey(Event, on_delete=models.CASCADE, related_name='sanctions_matches')
           entity_name = models.CharField(max_length=200)  # Name matched from event
           entity_type = models.CharField(max_length=50)  # 'person' or 'organization'
           sanctions_list = models.CharField(max_length=100)  # e.g., 'OFAC-SDN', 'UN-1267'
           match_score = models.FloatField()  # 0.0-1.0 fuzzy match confidence
           sanctions_data = models.JSONField()  # Full API response for reference
           sanctions_checked_at = models.DateTimeField(auto_now_add=True)
           created_at = models.DateTimeField(auto_now_add=True)
       ```

    4. Create migration: python manage.py makemigrations

    5. Add to requirements.txt if using library wrapper: None needed for direct API calls, use requests (already in dependencies via transitive)

    **What to avoid and WHY:** Don't create custom fuzzy matching logic - name variation complexity (32 spellings of "Gaddafi", transliterations, aliases) is massive. Use OpenSanctions/OFAC API which handles this.
  </action>
  <verify>python manage.py makemigrations shows new migration created, python manage.py check passes, OPENSANCTIONS_API_KEY appears in .env.example</verify>
  <done>SanctionsMatch model exists with proper fields, migration created, API configuration added to settings, requirements updated if needed</done>
</task>

<task type="auto">
  <name>Task 2: Implement sanctions_screener.py service with fuzzy entity matching</name>
  <files>backend/data_pipeline/services/sanctions_screener.py</files>
  <action>
    Create backend/data_pipeline/services/sanctions_screener.py implementing SanctionsScreener class:

    ```python
    class SanctionsScreener:
        """Screen entities against OpenSanctions/OFAC sanctions lists."""

        @classmethod
        def screen_event_entities(cls, event: Event) -> float:
            """
            Screen all entities in event against sanctions lists.
            Returns: sanctions_score (0.0 = clean, 1.0 = sanctioned)
            Creates SanctionsMatch records for any matches > 0.7 threshold.
            """
            # Extract entities from LLM analysis
            entities = event.llm_analysis.get('entities', {})
            people = entities.get('people', [])
            organizations = entities.get('organizations', [])

            max_match_score = 0.0

            # Screen people
            for person in people:
                matches = cls._check_person(person['name'])
                if matches:
                    # Create SanctionsMatch record
                    # Update max_match_score

            # Screen organizations
            for org in organizations:
                matches = cls._check_organization(org['name'])
                # Similar logic

            # Binary: any match > 0.7 = sanctioned
            return 1.0 if max_match_score > 0.7 else 0.0

        @classmethod
        def _check_person(cls, name: str) -> List[Dict]:
            """Fuzzy match person name against sanctions lists via API."""
            # Call OpenSanctions API: GET /match/default?schema=Person&properties.name={name}&threshold=0.6
            # Or OFAC API equivalent
            # Return list of matches with scores
            pass

        @classmethod
        def _check_organization(cls, name: str) -> List[Dict]:
            """Fuzzy match organization name against sanctions lists via API."""
            # Similar to _check_person but schema=Organization
            pass
    ```

    Implement actual API calls to OpenSanctions (preferred) or OFAC Sanctions List Service (free alternative).

    **What to avoid and WHY:** Don't download sanctions CSV files and do local matching - data staleness risk (2000+ updates/year) and fuzzy matching complexity. Use live API.
  </action>
  <verify>python manage.py shell: from data_pipeline.services.sanctions_screener import SanctionsScreener; result = SanctionsScreener._check_person("Nicolás Maduro"); assert isinstance(result, list)</verify>
  <done>sanctions_screener.py exists with SanctionsScreener class, screen_event_entities() method returns 0.0/1.0 score, _check_person and _check_organization call API with fuzzy threshold 0.6, SanctionsMatch records created for matches > 0.7</done>
</task>

<task type="auto">
  <name>Task 3: Create Celery task for daily sanctions screening refresh</name>
  <files>backend/data_pipeline/tasks/sanctions_tasks.py, backend/data_pipeline/tasks/__init__.py, backend/venezuelawatch/settings.py</files>
  <action>
    1. Create backend/data_pipeline/tasks/sanctions_tasks.py with daily refresh task:
       ```python
       from data_pipeline.tasks.base import BaseIngestionTask
       from data_pipeline.services.sanctions_screener import SanctionsScreener
       from core.models import Event, SanctionsMatch
       from datetime import timedelta

       @shared_task(base=BaseIngestionTask, bind=True, name='refresh_sanctions_screening')
       def refresh_sanctions_screening(self, lookback_days=7):
           """
           Re-screen recent events for sanctions matches.
           Runs daily to catch new sanctions additions.
           """
           cutoff_date = timezone.now() - timedelta(days=lookback_days)
           recent_events = Event.objects.filter(created_at__gte=cutoff_date).exclude(llm_analysis__isnull=True)

           screened_count = 0
           matches_found = 0

           for event in recent_events:
               # Delete old sanctions matches for this event
               SanctionsMatch.objects.filter(event=event).delete()

               # Re-screen
               sanctions_score = SanctionsScreener.screen_event_entities(event)

               if sanctions_score > 0.0:
                   matches_found += 1

               screened_count += 1

           return {"screened": screened_count, "matches_found": matches_found}
       ```

    2. Register task in backend/data_pipeline/tasks/__init__.py

    3. Add Celery Beat schedule in backend/venezuelawatch/settings.py CELERY_BEAT_SCHEDULE:
       ```python
       'refresh-sanctions-screening': {
           'task': 'refresh_sanctions_screening',
           'schedule': crontab(hour=4, minute=0),  # Daily at 4 AM UTC
       },
       ```

    **What to avoid and WHY:** Don't screen all historical events daily (expensive API calls). 7-day lookback captures recent events where sanctions changes most relevant.
  </action>
  <verify>celery -A config beat --loglevel=info shows refresh-sanctions-screening task scheduled at 4 AM UTC, python manage.py shell: from data_pipeline.tasks.sanctions_tasks import refresh_sanctions_screening; result = refresh_sanctions_screening.delay(); result.get() returns dict with screened/matches_found counts</verify>
  <done>sanctions_tasks.py created with refresh_sanctions_screening task, task registered in __init__.py, Celery Beat schedule added for daily 4 AM UTC execution, 7-day lookback configured</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] python manage.py check passes with no errors
- [ ] python manage.py makemigrations shows no unapplied migrations
- [ ] python manage.py migrate applies SanctionsMatch migration successfully
- [ ] Manual test: SanctionsScreener._check_person("Nicolas Maduro") returns API results
- [ ] Celery Beat shows refresh-sanctions-screening task scheduled
- [ ] Test event screening: Create test event with Maduro in entities, run screen_event_entities(), verify SanctionsMatch record created if API returns matches
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- SanctionsMatch model exists with proper schema
- sanctions_screener.py implements fuzzy API-based matching
- Daily sanctions refresh task scheduled
- No hardcoded API keys (use environment/Secret Manager)
- API calls use fuzzy threshold 0.6-0.7
- Sanctions matches stored with timestamps for freshness tracking
</success_criteria>

<output>
After completion, create `.planning/phases/04-risk-intelligence-core/04-01-SUMMARY.md`:

# Phase 4 Plan 1: Sanctions Screening Integration Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description
- `path/to/another.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 04-02-PLAN.md (Multi-Dimensional Risk Aggregation)
</output>
