---
phase: 02-authentication-user-management
plan: 04
type: execute
---

<objective>
Build React authentication UI with login/register forms, auth context, and protected route wrapper.

Purpose: Complete authentication frontend integration so users can sign up, log in, and access protected features in the React application.
Output: Working login and registration forms, auth context managing user state, protected route component, automatic token refresh.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-user-management/DISCOVERY.md
@.planning/phases/02-authentication-user-management/02-01-SUMMARY.md
@.planning/phases/02-authentication-user-management/02-02-SUMMARY.md
@.planning/phases/02-authentication-user-management/02-03-SUMMARY.md

**Tech stack available:**
- React 18 with TypeScript
- Vite dev server with proxy to Django backend
- Typed API client pattern from Phase 1
- Authentication API at /_allauth/auth/
- User profile API at /api/user/me

**Key files:**
@frontend/src/lib/api.ts
@frontend/src/App.tsx
@frontend/src/main.tsx

**Constraining decisions:**
- Phase 1: Typed API client pattern (extend for auth endpoints)
- Phase 1: Vite proxy forwards /api and /_allauth to Django
- Plan 02-02: JWT tokens in httpOnly cookies (automatic with fetch)
- Plan 02-03: User profile at /api/user/me
- Discovery: React Context API for auth state (not Redux/Zustand for Phase 2)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend API client with authentication methods</name>
  <files>frontend/src/lib/api.ts</files>
  <action>
In frontend/src/lib/api.ts:

1. Add TypeScript interfaces for auth responses:

```typescript
export interface User {
  id: number
  email: string
  username: string
  first_name: string
  last_name: string
  organization_name: string
  role: 'individual' | 'team_member' | 'team_admin' | 'org_admin'
  subscription_tier: 'free' | 'pro' | 'enterprise'
  timezone: string
  date_joined: string
}

export interface AuthResponse {
  user: User
  access_token?: string  // Optional - we use httpOnly cookies
}

export interface RegisterData {
  email: string
  password: string
  password_confirm: string
}

export interface LoginData {
  email: string
  password: string
}
```

2. Add authentication methods to api object:

```typescript
export const api = {
  // Existing health check
  async healthCheck(): Promise<HealthResponse> {
    const response = await fetch(`${API_BASE}/health/health`, {
      credentials: 'include',  // Include cookies
    })
    if (!response.ok) {
      throw new Error(`API error: ${response.status}`)
    }
    return response.json()
  },

  // Authentication methods
  async register(data: RegisterData): Promise<AuthResponse> {
    const response = await fetch('/_allauth/auth/registration/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include',  // Important: send/receive cookies
      body: JSON.stringify(data),
    })
    if (!response.ok) {
      const error = await response.json()
      throw new Error(error.message || 'Registration failed')
    }
    return response.json()
  },

  async login(data: LoginData): Promise<AuthResponse> {
    const response = await fetch('/_allauth/auth/login/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include',
      body: JSON.stringify(data),
    })
    if (!response.ok) {
      const error = await response.json()
      throw new Error(error.message || 'Login failed')
    }
    return response.json()
  },

  async logout(): Promise<void> {
    const response = await fetch('/_allauth/auth/logout/', {
      method: 'POST',
      credentials: 'include',
    })
    if (!response.ok) {
      throw new Error('Logout failed')
    }
  },

  async getCurrentUser(): Promise<User> {
    const response = await fetch(`${API_BASE}/user/me`, {
      credentials: 'include',
    })
    if (!response.ok) {
      throw new Error(`Failed to fetch user: ${response.status}`)
    }
    return response.json()
  },
}
```

Key points:
- `credentials: 'include'` is CRITICAL for httpOnly cookies to work cross-origin
- Vite proxy handles the actual cross-origin request to Django
- TypeScript interfaces match backend User model
- Error handling extracts message from response

Do NOT use axios or any other HTTP library - fetch is sufficient and avoids extra dependencies.
  </action>
  <verify>
grep "export interface User" frontend/src/lib/api.ts exists
grep "credentials: 'include'" frontend/src/lib/api.ts shows multiple occurrences
grep "async register" frontend/src/lib/api.ts exists
grep "async login" frontend/src/lib/api.ts exists
  </verify>
  <done>API client extended with register, login, logout, getCurrentUser methods. TypeScript interfaces defined. credentials: 'include' set for cookie authentication.</done>
</task>

<task type="auto">
  <name>Task 2: Create auth context and provider</name>
  <files>frontend/src/contexts/AuthContext.tsx</files>
  <action>
Create new file frontend/src/contexts/AuthContext.tsx:

```typescript
import React, { createContext, useContext, useState, useEffect } from 'react'
import { User, api } from '../lib/api'

interface AuthContextType {
  user: User | null
  loading: boolean
  error: string | null
  login: (email: string, password: string) => Promise<void>
  register: (email: string, password: string, passwordConfirm: string) => Promise<void>
  logout: () => Promise<void>
  refreshUser: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // Check authentication status on mount
  useEffect(() => {
    checkAuth()
  }, [])

  async function checkAuth() {
    try {
      const currentUser = await api.getCurrentUser()
      setUser(currentUser)
      setError(null)
    } catch (err) {
      // Not authenticated - this is fine
      setUser(null)
    } finally {
      setLoading(false)
    }
  }

  async function login(email: string, password: string) {
    setLoading(true)
    setError(null)
    try {
      await api.login({ email, password })
      await checkAuth()  // Fetch user details after login
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Login failed')
      throw err
    } finally {
      setLoading(false)
    }
  }

  async function register(email: string, password: string, passwordConfirm: string) {
    setLoading(true)
    setError(null)
    try {
      await api.register({ email, password, password_confirm: passwordConfirm })
      await checkAuth()  // Fetch user details after registration
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Registration failed')
      throw err
    } finally {
      setLoading(false)
    }
  }

  async function logout() {
    setLoading(true)
    setError(null)
    try {
      await api.logout()
      setUser(null)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Logout failed')
      throw err
    } finally {
      setLoading(false)
    }
  }

  async function refreshUser() {
    try {
      const currentUser = await api.getCurrentUser()
      setUser(currentUser)
      setError(null)
    } catch (err) {
      setUser(null)
    }
  }

  return (
    <AuthContext.Provider value={{ user, loading, error, login, register, logout, refreshUser }}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}
```

Why Context API instead of state library:
- Sufficient for Phase 2 authentication state
- No extra dependencies
- Can upgrade to Zustand/Redux later if needed
- Follows React best practices

Do NOT add complex token refresh logic - httpOnly cookies handle this automatically via Django.
  </action>
  <verify>
grep "export function AuthProvider" frontend/src/contexts/AuthContext.tsx exists
grep "export function useAuth" frontend/src/contexts/AuthContext.tsx exists
grep "createContext" frontend/src/contexts/AuthContext.tsx exists
  </verify>
  <done>AuthContext created with user state, loading, error, and auth methods. useAuth hook exported for component usage. AuthProvider wraps app to provide context.</done>
</task>

<task type="auto">
  <name>Task 3: Create login and registration forms</name>
  <files>frontend/src/components/LoginForm.tsx, frontend/src/components/RegisterForm.tsx, frontend/src/App.tsx, frontend/src/main.tsx</files>
  <action>
1. Create frontend/src/components/LoginForm.tsx:

```typescript
import { useState } from 'react'
import { useAuth } from '../contexts/AuthContext'

export function LoginForm() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const { login, loading, error } = useAuth()

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    try {
      await login(email, password)
      // Auth context handles user state update
    } catch (err) {
      // Error already set in context
    }
  }

  return (
    <form onSubmit={handleSubmit} style={{ maxWidth: '400px', margin: '0 auto' }}>
      <h2>Login</h2>
      {error && <p style={{ color: 'red' }}>{error}</p>}
      <div style={{ marginBottom: '1rem' }}>
        <label>
          Email:
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
            style={{ width: '100%', padding: '0.5rem' }}
          />
        </label>
      </div>
      <div style={{ marginBottom: '1rem' }}>
        <label>
          Password:
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
            style={{ width: '100%', padding: '0.5rem' }}
          />
        </label>
      </div>
      <button type="submit" disabled={loading} style={{ padding: '0.5rem 1rem' }}>
        {loading ? 'Logging in...' : 'Login'}
      </button>
    </form>
  )
}
```

2. Create frontend/src/components/RegisterForm.tsx:

```typescript
import { useState } from 'react'
import { useAuth } from '../contexts/AuthContext'

export function RegisterForm() {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [passwordConfirm, setPasswordConfirm] = useState('')
  const { register, loading, error } = useAuth()

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    if (password !== passwordConfirm) {
      alert('Passwords do not match')
      return
    }
    try {
      await register(email, password, passwordConfirm)
      // Auth context handles user state update
    } catch (err) {
      // Error already set in context
    }
  }

  return (
    <form onSubmit={handleSubmit} style={{ maxWidth: '400px', margin: '0 auto' }}>
      <h2>Register</h2>
      {error && <p style={{ color: 'red' }}>{error}</p>}
      <div style={{ marginBottom: '1rem' }}>
        <label>
          Email:
          <input
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
            style={{ width: '100%', padding: '0.5rem' }}
          />
        </label>
      </div>
      <div style={{ marginBottom: '1rem' }}>
        <label>
          Password:
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
            minLength={8}
            style={{ width: '100%', padding: '0.5rem' }}
          />
        </label>
      </div>
      <div style={{ marginBottom: '1rem' }}>
        <label>
          Confirm Password:
          <input
            type="password"
            value={passwordConfirm}
            onChange={(e) => setPasswordConfirm(e.target.value)}
            required
            minLength={8}
            style={{ width: '100%', padding: '0.5rem' }}
          />
        </label>
      </div>
      <button type="submit" disabled={loading} style={{ padding: '0.5rem 1rem' }}>
        {loading ? 'Creating account...' : 'Register'}
      </button>
    </form>
  )
}
```

3. Update frontend/src/App.tsx to show forms and user profile:

```typescript
import { useAuth } from './contexts/AuthContext'
import { LoginForm } from './components/LoginForm'
import { RegisterForm } from './components/RegisterForm'
import './App.css'
import { useState } from 'react'

function App() {
  const { user, loading, logout } = useAuth()
  const [showRegister, setShowRegister] = useState(false)

  if (loading) {
    return <div>Loading...</div>
  }

  if (!user) {
    return (
      <div className="App">
        <h1>VenezuelaWatch</h1>
        <p>Real-time intelligence platform for Venezuela events</p>

        {showRegister ? <RegisterForm /> : <LoginForm />}

        <p style={{ marginTop: '2rem' }}>
          <button onClick={() => setShowRegister(!showRegister)} style={{ background: 'none', border: 'none', color: 'blue', textDecoration: 'underline', cursor: 'pointer' }}>
            {showRegister ? 'Already have an account? Login' : "Don't have an account? Register"}
          </button>
        </p>
      </div>
    )
  }

  return (
    <div className="App">
      <h1>VenezuelaWatch</h1>
      <p>Welcome, {user.email}!</p>

      <div style={{ marginTop: '2rem', padding: '1rem', border: '1px solid #ccc', maxWidth: '400px', margin: '2rem auto' }}>
        <h2>User Profile</h2>
        <p><strong>Email:</strong> {user.email}</p>
        <p><strong>Role:</strong> {user.role}</p>
        <p><strong>Subscription:</strong> {user.subscription_tier}</p>
        <p><strong>Organization:</strong> {user.organization_name || 'None'}</p>
        <p><strong>Joined:</strong> {new Date(user.date_joined).toLocaleDateString()}</p>
      </div>

      <button onClick={logout} style={{ padding: '0.5rem 1rem', marginTop: '1rem' }}>
        Logout
      </button>
    </div>
  )
}

export default App
```

4. Update frontend/src/main.tsx to wrap app with AuthProvider:

```typescript
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import { AuthProvider } from './contexts/AuthContext.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <AuthProvider>
      <App />
    </AuthProvider>
  </React.StrictMode>,
)
```

Styling notes:
- Using inline styles for Phase 2 simplicity
- Can be replaced with CSS modules or Tailwind in future
- Functional UI is priority over design polish

Do NOT add password strength indicators, email validation UI, or complex styling - functional forms are sufficient for Phase 2.
  </action>
  <verify>
ls frontend/src/components/LoginForm.tsx exists
ls frontend/src/components/RegisterForm.tsx exists
grep "AuthProvider" frontend/src/main.tsx exists
grep "useAuth" frontend/src/App.tsx exists
  </verify>
  <done>LoginForm and RegisterForm components created. App.tsx shows appropriate UI based on auth state. Main.tsx wraps app with AuthProvider. Forms functional with loading and error states.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete React authentication UI with registration, login, user profile display, and logout functionality</what-built>
  <how-to-verify>
    1. Start Django backend:
       cd backend && python manage.py runserver

    2. Start React frontend (new terminal):
       cd frontend && npm run dev

    3. Visit: http://localhost:5173

    4. Test Registration:
       - Should see LoginForm by default
       - Click "Don't have an account? Register"
       - Fill in email (test@venezuelawatch.com), password (minimum 8 chars)
       - Click "Register"
       - Should automatically log in and show user profile

    5. Test Logout:
       - Click "Logout" button
       - Should return to LoginForm

    6. Test Login:
       - Enter same email/password
       - Click "Login"
       - Should show user profile with:
         * Email
         * Role: individual
         * Subscription: free
         * Organization: None
         * Join date

    7. Verify protected API:
       - Open browser DevTools → Network tab
       - Check requests to /_allauth/auth/ endpoints (should be 2xx)
       - Check request to /api/user/me (should be 200)
       - Verify cookies are set (Application → Cookies → access_token, refresh_token)

    8. Test authentication persistence:
       - Refresh the page (F5)
       - Should remain logged in (user profile still shown)

    9. Test error handling:
       - Logout
       - Try to login with wrong password
       - Should show error message "Login failed" or similar
       - Error should be displayed in red above form

    Expected behavior:
    - Forms are functional and styled (basic inline styles)
    - Registration creates account and logs in automatically
    - Login shows user profile after success
    - Logout returns to login form
    - Errors are displayed clearly
    - Page refresh maintains authentication state
    - Network requests show proper cookies and responses
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe any issues for me to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run dev starts frontend without errors
- [ ] TypeScript compilation passes
- [ ] Registration flow works end-to-end
- [ ] Login flow works end-to-end
- [ ] Logout clears user state
- [ ] User profile displays after authentication
- [ ] Page refresh maintains authentication
- [ ] Error messages display on auth failures
- [ ] Browser cookies show access_token and refresh_token
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- User can register new account
- User can log in with existing account
- User can log out
- Protected user data displays correctly
- Authentication persists across page refreshes
- Phase 2 complete - full authentication system working
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-user-management/02-04-SUMMARY.md`:

---
phase: 02-authentication-user-management
plan: 04
subsystem: ui
tags: [react, authentication, login-form, user-profile]

requires:
  - phase: 01-02
    provides: React 18 frontend, Vite proxy, typed API client
  - phase: 02-02
    provides: Authentication API endpoints
  - phase: 02-03
    provides: User profile endpoint

provides:
  - AuthContext and useAuth hook for authentication state
  - LoginForm and RegisterForm components
  - User profile display
  - Complete authentication flow (register → login → logout)
  - httpOnly cookie authentication working cross-origin

affects: [future-dashboard, future-protected-features]

tech-stack:
  patterns: [React Context API for auth state, credentials: 'include' for cookies, Protected UI based on user state]

key-files:
  created:
    - frontend/src/contexts/AuthContext.tsx
    - frontend/src/components/LoginForm.tsx
    - frontend/src/components/RegisterForm.tsx
  modified:
    - frontend/src/lib/api.ts
    - frontend/src/App.tsx
    - frontend/src/main.tsx

key-decisions:
  - "React Context API for auth state management (sufficient for Phase 2)"
  - "credentials: 'include' in fetch for httpOnly cookie authentication"
  - "Inline styles for forms (can be upgraded to CSS framework later)"
  - "Auto-login after registration for better UX"

---

# Plan 02-04 Summary: React Authentication UI

**[Substantive one-liner]**

## Accomplishments

- Created AuthContext with useAuth hook for auth state management
- Built LoginForm and RegisterForm components
- Updated App.tsx to show UI based on authentication state
- Tested complete authentication flow (register, login, logout)
- Verified httpOnly cookies work across Vite proxy

## Files Created/Modified

### Created:
- `frontend/src/contexts/AuthContext.tsx` - Auth state and methods
- `frontend/src/components/LoginForm.tsx` - Login form component
- `frontend/src/components/RegisterForm.tsx` - Registration form

### Modified:
- `frontend/src/lib/api.ts` - Added auth methods with User interface
- `frontend/src/App.tsx` - Conditional rendering based on auth state
- `frontend/src/main.tsx` - Wrapped app with AuthProvider

## Decisions Made

1. **React Context API**: Using Context API instead of Zustand/Redux for Phase 2 simplicity
2. **Auto-login After Registration**: Better UX - user doesn't need to login after registering
3. **Inline Styles**: Basic styling sufficient for Phase 2, can upgrade to Tailwind/CSS modules later
4. **credentials: 'include'**: Critical for httpOnly cookies to work cross-origin via Vite proxy

## Issues Encountered

[None or describe any issues]

## Phase Complete

**Phase 2: Authentication & User Management** is complete.

All authentication features working:
- ✓ django-allauth with JWT configured
- ✓ Custom User model with team-ready fields
- ✓ Authentication API endpoints
- ✓ Protected API routes
- ✓ React authentication UI
- ✓ Full authentication flow tested

---

</output>
