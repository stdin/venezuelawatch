---
phase: 26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking
plan: 04
type: execute
---

<objective>
Add GKG theme filtering and event lineage for comprehensive pattern discovery.

Purpose: Enable theme-based filtering to show activity-specific networks (sanctions, trade, unrest), and add temporal lineage visualization showing how events cascade over time (A→B→C causal chains).
Output: Theme filtering operational, event lineage reveals temporal patterns and cascade effects.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking/26-RESEARCH.md
@.planning/phases/26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking/26-CONTEXT.md
@.planning/phases/26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking/26-03-SUMMARY.md

**Updated phase context:**
- **Theme filtering:** Show activity-specific networks (sanctions, trade, political)
- **Event lineage:** Temporal causal chains revealing cascade effects (A→B→C)
- **Progressive disclosure:** Timeline view expands narrative with full event sequence
- **Pattern discovery:** Themes cluster by activity type, lineage shows cause-and-effect

**Research findings:**
- GDELT GKG V2Themes: 2,500+ themes taxonomy (Nov 2021 update)
- Format: "THEME1,offset1,offset2;THEME2,offset3,offset4" (semicolon-separated mentions)
- World Bank taxonomy integrated (WB_1234_XYZ format)
- Phase 20 already stores GKG data in metadata.gkg_data.V2Themes

**Tech stack:**
- GKG data available from Phase 20 (stored in event metadata)
- BigQuery events have metadata JSON field with gkg_data
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create theme enricher service</name>
  <files>backend/data_pipeline/services/theme_enricher.py</files>
  <action>
Create ThemeEnricher service for parsing GKG themes:

**parse_gkg_themes(v2_themes_string: str) -> List[str]:**
- Parse GDELT V2Themes format: "THEME1,offset1,offset2;THEME2,offset3,offset4"
- Split on ';' for theme mentions
- For each mention, split on ',' and extract theme name (parts[0])
- Return list of unique theme names
- Handle empty/null strings gracefully (return empty list)

**categorize_relationship(theme_list: List[str]) -> str:**
- Map themes to relationship categories:
  - Contains 'SANCTION' or 'EMBARGO' → 'sanctions'
  - Contains 'TRADE' or 'EXPORT' → 'trade'
  - Contains 'LEADER' or 'GOV_' → 'political'
  - Contains 'UNREST' or 'PROTEST' → 'adversarial'
  - Contains 'OIL' or 'ENERGY' → 'energy'
  - Else → 'other'
- Return primary category string

**enrich_edge_with_themes(edge: Dict, event_ids: List[str]) -> Dict:**
- Fetch events by IDs from BigQuery
- Extract V2Themes from each event's metadata.gkg_data
- Parse themes using parse_gkg_themes()
- Aggregate unique themes across all connecting events
- Categorize using categorize_relationship()
- Add to edge.data: {themes: List[str], category: str}
- Return enriched edge

Follow Phase 20 GKG parsing patterns. Handle missing GKG data gracefully - not all events have GKG records.

Don't download LOOKUP-GKGTHEMES.TXT yet - simple pattern matching is sufficient for Phase 26. Full theme taxonomy lookup is future enhancement.
  </action>
  <verify>python -c "from backend.data_pipeline.services.theme_enricher import ThemeEnricher; te = ThemeEnricher(); themes = te.parse_gkg_themes('WB_1234_SANCTIONS,0,10;ECON_TRADE,15,25'); print(themes)" prints ['WB_1234_SANCTIONS', 'ECON_TRADE']</verify>
  <done>ThemeEnricher service parses GKG V2Themes format, categorizes relationships, enriches edges with theme lists and categories</done>
</task>

<task type="auto">
  <name>Task 2: Add theme filtering to graph API and UI</name>
  <files>backend/api/views/graph.py, backend/data_pipeline/services/graph_builder.py, frontend/src/components/EntityGraph/ThemeFilter.tsx, frontend/src/pages/GraphPage.tsx</files>
  <action>
Update GraphBuilder and API endpoint to support theme filtering:

**GraphBuilder.build_entity_graph():**
- Add optional theme_filter parameter: Union[str, List[str], None]
- If theme_filter provided:
  - After building edges, call ThemeEnricher.enrich_edge_with_themes() for each edge
  - Filter edges where edge.data.category in theme_filter (if string) or any(cat in theme_filter for cat in categories)
  - Remove nodes that have no remaining edges (isolated nodes)
- Return graph with theme-filtered edges

**API endpoint update:**
- Add query param: theme_categories (optional comma-separated string: "sanctions,trade,energy")
- Parse into list, pass to build_entity_graph(theme_filter=categories)
- Return filtered graph

**GraphResponse schema update:**
Add optional fields to Edge:
```python
class EdgeData(Schema):
    event_ids: List[str]
    strength: int
    themes: Optional[List[str]] = None
    category: Optional[str] = None
```

Don't implement theme search/autocomplete yet - that's future enhancement. Predefined categories (sanctions, trade, political, adversarial, energy, other) are sufficient.

Handle performance: Theme enrichment requires BigQuery queries for event metadata. Only enrich if theme_filter is provided (don't enrich all edges by default).

**ThemeFilter UI component:**
Create ThemeFilter.tsx with multi-select chips:

**ThemeFilter.tsx:**
```tsx
import { Group, Chip } from '@mantine/core';

interface Props {
  selectedThemes: string[];
  onChange: (themes: string[]) => void;
}

const THEME_OPTIONS = [
  { value: 'sanctions', label: 'Sanctions', color: 'red' },
  { value: 'trade', label: 'Trade', color: 'blue' },
  { value: 'political', label: 'Political', color: 'violet' },
  { value: 'energy', label: 'Energy', color: 'orange' },
  { value: 'adversarial', label: 'Adversarial', color: 'grape' },
];

export const ThemeFilter = ({ selectedThemes, onChange }: Props) => {
  return (
    <Chip.Group multiple value={selectedThemes} onChange={onChange}>
      <Group gap="xs">
        {THEME_OPTIONS.map(theme => (
          <Chip key={theme.value} value={theme.value} color={theme.color}>
            {theme.label}
          </Chip>
        ))}
      </Group>
    </Chip.Group>
  );
};
```

**Update EntityGraph.tsx:**
- Add selectedThemes state
- Pass to useGraphData hook: useGraphData({ selectedThemes })
- Update fetch to include theme_categories query param

**Update GraphPage.tsx:**
- Add ThemeFilter above graph: `<ThemeFilter selectedThemes={themes} onChange={setThemes} />`
- Show active filter count: "Showing {filteredEdgeCount} relationships" when themes selected

Use Mantine Chip.Group for multi-select toggle pattern (Phase 11 patterns). Don't add "Clear All" button yet - clicking active chips to deselect is sufficient.
  </action>
  <verify>curl "http://localhost:8000/api/graph/entities?theme_categories=sanctions,trade" returns filtered graph; visit /graph, click theme chips, graph updates to show only selected categories</verify>
  <done>Theme filtering operational in API and UI, graph shows activity-specific networks, edges enriched with GKG themes and categories</done>
</task>

<task type="auto">
  <name>Task 3: Create event lineage query service</name>
  <files>backend/data_pipeline/services/lineage_builder.py</files>
  <action>
Create LineageBuilder service for temporal event chains:

**build_event_lineage(entity_a_id, entity_b_id, max_events=20) -> Dict:**
- Query BigQuery for events where both entities appear (via metadata.linked_entities)
- Sort chronologically by published_at ASC (oldest first for temporal sequence)
- Identify potential causal patterns:
  - Events within 30 days of each other (temporal proximity)
  - Risk score increases over time (escalation indicator)
  - Theme continuity (same GKG themes repeated)
- Return structured lineage:
  ```python
  {
    'events': List[EventNode],  # Chronological event sequence
    'timeline_spans_days': int,  # Total time span
    'escalation_detected': bool,  # Risk scores trending up
    'dominant_themes': List[str]  # Most frequent GKG themes
  }

  class EventNode:
    id: str
    title: str
    published_at: datetime
    risk_score: float
    severity: str
    themes: List[str]
    days_since_prev: Optional[int]  # Gap from previous event
  ```
- Calculate days_since_prev for each event (None for first event)
- Detect escalation: Compare first event risk_score vs last event risk_score

**Temporal proximity heuristic:**
- Events within 7 days: Strong causal signal
- Events within 30 days: Moderate causal signal
- Events >30 days apart: Correlation, not necessarily causation

Don't implement graph algorithms for causal inference - simple temporal sequencing with proximity heuristics is sufficient for Phase 26. Advanced causal detection is future enhancement.

Follow BigQuery query patterns from Phase 14-18. Use parameterized queries to prevent SQL injection.
  </action>
  <verify>python -c "from backend.data_pipeline.services.lineage_builder import LineageBuilder; lb = LineageBuilder(); lineage = lb.build_event_lineage(entity_a_id, entity_b_id); print(lineage['timeline_spans_days'])" returns integer days without errors</verify>
  <done>LineageBuilder service queries chronological event sequences, detects escalation patterns, returns structured timeline data for visualization</done>
</task>

<task type="auto">
  <name>Task 4: Enhance EdgeNarrative modal with timeline view</name>
  <files>frontend/src/components/EntityGraph/EdgeNarrative.tsx, backend/api/views/graph.py</files>
  <action>
Add event lineage timeline visualization to EdgeNarrative modal:

**Backend API update (graph.py):**
- Update GET /api/graph/narrative/{entity_a_id}/{entity_b_id} endpoint
- Call LineageBuilder().build_event_lineage(entity_a_id, entity_b_id)
- Include lineage data in NarrativeResponse:
  ```python
  class NarrativeResponse(Schema):
    narrative: str
    events: List[EventSummary]  # Existing
    entity_a: EntityInfo  # Existing
    entity_b: EntityInfo  # Existing
    lineage: Optional[EventLineage] = None  # New

  class EventLineage(Schema):
    events: List[EventNode]
    timeline_spans_days: int
    escalation_detected: bool
    dominant_themes: List[str]
  ```

**Frontend EdgeNarrative.tsx enhancement:**
Add timeline visualization using Mantine Timeline component:
```tsx
import { Timeline, Text, Badge, Group, Stack } from '@mantine/core';

{data.lineage && (
  <Box mt="lg">
    <Text fw={600} mb="xs">Event Timeline ({data.lineage.timeline_spans_days} days):</Text>

    {data.lineage.escalation_detected && (
      <Alert color="orange" mb="xs">
        ⚠️ Escalation detected: Risk increased over time
      </Alert>
    )}

    <Timeline active={data.lineage.events.length - 1} bulletSize={24}>
      {data.lineage.events.map((event, idx) => (
        <Timeline.Item
          key={event.id}
          title={event.title}
          bullet={<Text size="xs">{idx + 1}</Text>}
        >
          <Group gap="xs" mt={4}>
            <Badge size="sm">{event.severity}</Badge>
            <Badge size="sm" color="orange">Risk: {event.risk_score.toFixed(0)}</Badge>
            <Text size="xs" c="dimmed">
              {new Date(event.published_at).toLocaleDateString()}
              {event.days_since_prev && ` (+${event.days_since_prev}d)`}
            </Text>
          </Group>
          {event.themes.length > 0 && (
            <Group gap={4} mt={4}>
              {event.themes.slice(0, 3).map(theme => (
                <Badge key={theme} size="xs" variant="light">{theme}</Badge>
              ))}
            </Group>
          )}
        </Timeline.Item>
      ))}
    </Timeline>
  </Box>
)}
```

Use Mantine Timeline for vertical event sequence. Show days_since_prev to highlight temporal gaps. Display dominant_themes at top for pattern context.

Don't implement interactive timeline scrubbing - static timeline display is sufficient for progressive disclosure pattern.
  </action>
  <verify>Click edge in graph, modal shows timeline with chronological events, escalation alert if risk increased, themes displayed per event</verify>
  <done>EdgeNarrative modal enhanced with timeline visualization, shows temporal event sequences with causal indicators (gaps, escalation, themes), progressive disclosure pattern complete</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] GKG V2Themes parsing handles semicolon/comma delimiters correctly
- [ ] Relationship categorization maps themes to categories
- [ ] Graph API returns theme-filtered results
- [ ] ThemeFilter UI toggles update graph display
- [ ] Event lineage service returns chronological sequences
- [ ] Timeline visualization shows events in temporal order
- [ ] Escalation detection identifies risk increases
- [ ] Theme context displayed in timeline
- [ ] No errors when data missing (graceful fallbacks)
- [ ] Phase 26 complete: all 4 plans executed
</verification>

<success_criteria>

- All tasks completed (4/4)
- All verification checks pass
- **Theme filtering:** Activity-specific networks visible via GKG categories
- **Event lineage:** Temporal causal chains show how events cascade (A→B→C)
- **Pattern discovery complete:** Auto-focus + narratives + themes + lineage operational
- **Progressive disclosure:** Timeline view expands narrative with full event sequence
- Phase 26 complete: All pattern discovery features shipped
- Ready for Phase 27 (rolling window statistics, persistence detection)
</success_criteria>

<output>
After completion, create `.planning/phases/26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking/26-04-SUMMARY.md`

**Phase complete - all 4 plans executed.**
</output>
