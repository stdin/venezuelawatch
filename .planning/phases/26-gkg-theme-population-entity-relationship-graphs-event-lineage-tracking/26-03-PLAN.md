---
phase: 26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking
plan: 03
type: execute
---

<objective>
Implement camera auto-focus and edge narratives for pattern discovery.

Purpose: Auto-zoom to largest high-risk cluster immediately (no manual search), then enable edge-click narratives showing LLM-generated causal chains explaining HOW/WHY entities are connected.
Output: Camera focuses on critical intelligence automatically, edge narratives reveal connection stories with supporting events.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking/26-RESEARCH.md
@.planning/phases/26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking/26-CONTEXT.md
@.planning/phases/26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking/26-02-SUMMARY.md

**Updated phase context:**
- **Primary goal:** Pattern discovery through auto-focus + narratives (CONTEXT.md update)
- **Auto-focus:** Zoom to largest high-risk cluster (balance risk level + cluster size)
- **Edge narratives:** LLM-generated causal chains explaining connections
- **Progressive disclosure:** Overview first, expand details on demand

**Tech stack:**
- Anthropic Claude (claude-3-5-sonnet-20241022) - Phase 7 decision, already in project
- BigQuery for event queries (Phase 14-18 polyglot architecture)

**Research findings:**
- 2025 research shows LLMs use superficial heuristics for causal reasoning
- Must structure prompts with explicit event sequences and ask for causal relationships
- Don't use naive LLM prompting - provide event metadata (risk scores, severity, themes)
- Ask LLM to cite specific evidence from events
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement camera auto-focus to largest high-risk cluster</name>
  <files>frontend/src/components/EntityGraph/EntityGraph.tsx, frontend/src/components/EntityGraph/useGraphData.ts</files>
  <action>
Add camera auto-focus to Reagraph GraphCanvas using camera control API:

**useGraphData.ts enhancement:**
- Backend already returns `high_risk_cluster` ID from community detection
- Extract nodes belonging to high_risk_cluster from communities data
- Calculate centroid (average x, y positions) of high-risk cluster nodes
- Return: {nodes, edges, highRiskCluster, clusterCentroid, ...}

**EntityGraph.tsx camera focus:**
```tsx
import { GraphCanvas, GraphCanvasRef } from 'reagraph';

const graphRef = useRef<GraphCanvasRef>(null);
const { clusterCentroid, highRiskCluster } = useGraphData();

useEffect(() => {
  if (graphRef.current && clusterCentroid && highRiskCluster !== null) {
    // Auto-focus after graph renders
    setTimeout(() => {
      graphRef.current?.centerGraph([clusterCentroid.x, clusterCentroid.y, clusterCentroid.z || 0]);
    }, 500); // Delay for initial layout
  }
}, [clusterCentroid, highRiskCluster]);

return (
  <GraphCanvas
    ref={graphRef}
    // ... other props
  />
);
```

**Centroid calculation:**
- Filter nodes where `node.data.community === highRiskCluster`
- Average their positions (note: positions are assigned by Reagraph's force-directed layout)
- Since we don't have positions pre-layout, use camera.centerGraph() after render delay
- Alternative: Use Reagraph's built-in selection and camera APIs

Use Reagraph camera ref API (check Reagraph docs for GraphCanvasRef interface). The graph already highlights clusters via `clusterAttribute="community"`.

Don't implement manual zoom controls yet - auto-focus on load is sufficient. User can still pan/zoom manually after.
  </action>
  <verify>Open /graph, verify camera automatically zooms to the cluster with highest risk (check that it's not showing entire graph at default zoom)</verify>
  <done>Camera automatically frames largest high-risk cluster on graph load, cluster nodes centered in view, user sees critical intelligence immediately without manual navigation</done>
</task>

<task type="auto">
  <name>Task 2: Create narrative generator service</name>
  <files>backend/data_pipeline/services/narrative_generator.py</files>
  <action>
Create NarrativeGenerator service using Claude API:

**generate_relationship_narrative(entity_a: Entity, entity_b: Entity, connecting_events: List[Dict]) -> str:**
- Sort connecting_events chronologically by published_at
- Build event sequence context string:
  ```
  - {date}: {title} (Risk: {risk_score}, Severity: {severity}, Themes: {themes})
  ```
- Create structured prompt:
  ```
  You are an intelligence analyst explaining how two entities are connected through events.

  Entity A: {entity_a.name} ({entity_a.entity_type})
  Entity B: {entity_b.name} ({entity_b.entity_type})

  Connecting Events (chronological):
  {event_context}

  Generate a concise causal narrative (2-3 sentences) explaining:
  1. HOW these entities are connected (direct relationship or indirect through events)
  2. WHY this relationship matters (risk implications)
  3. WHAT happened in sequence (causal chain)

  Focus on causality, not just co-occurrence. Be specific about evidence from events.
  ```
- Call Anthropic API: client.messages.create(model="claude-3-5-sonnet-20241022", max_tokens=300)
- Return generated text

**get_connecting_events(entity_a_id, entity_b_id, limit=10) helper:**
- Query BigQuery for events where both entities appear (via metadata.linked_entities)
- Return most recent events, sorted by published_at DESC
- Include: id, title, published_at, risk_score, severity, themes from GKG

Use settings.ANTHROPIC_API_KEY (already configured in Phase 7).

Don't validate narrative accuracy - that's out of scope. Trust Claude's causal reasoning with structured prompt (RESEARCH.md guidance).
  </action>
  <verify>python -c "from backend.data_pipeline.services.narrative_generator import NarrativeGenerator; ng = NarrativeGenerator(); narrative = ng.generate_relationship_narrative(entity_a, entity_b, events); print(narrative)" returns 2-3 sentence narrative without API errors</verify>
  <done>NarrativeGenerator service generates causal narratives using Claude API, prompts include event sequences and metadata, returns 2-3 sentence explanations</done>
</task>

<task type="auto">
  <name>Task 3: Add narrative API endpoint</name>
  <files>backend/api/views/graph.py</files>
  <action>
Add GET /api/graph/narrative/{entity_a_id}/{entity_b_id} to GraphRouter:

**Endpoint:**
- Path params: entity_a_id (str), entity_b_id (str)
- Fetch both Entity objects from PostgreSQL
- Call NarrativeGenerator().get_connecting_events(entity_a_id, entity_b_id)
- If no connecting events: return {narrative: "No direct connection found", events: []}
- If events exist: call generate_relationship_narrative(entity_a, entity_b, events)
- Return NarrativeResponse: {narrative: str, events: List[EventSummary], entity_a: EntityInfo, entity_b: EntityInfo}

**Response schemas:**
```python
class EventSummary(Schema):
    id: str
    title: str
    published_at: str
    risk_score: float
    severity: str

class EntityInfo(Schema):
    id: str
    name: str
    entity_type: str

class NarrativeResponse(Schema):
    narrative: str
    events: List[EventSummary]
    entity_a: EntityInfo
    entity_b: EntityInfo
```

Handle errors: 404 if entities not found, 500 if Claude API fails (log error, return generic message).

Don't cache narratives - generate fresh each time for now. Caching is performance optimization for later.
  </action>
  <verify>curl http://localhost:8000/api/graph/narrative/{id_a}/{id_b} returns JSON with narrative and event list</verify>
  <done>Narrative endpoint functional, returns LLM-generated causal explanation with supporting events, error handling for missing entities</done>
</task>

<task type="auto">
  <name>Task 4: Create EdgeNarrative modal component</name>
  <files>frontend/src/components/EntityGraph/EdgeNarrative.tsx, frontend/src/components/EntityGraph/EntityGraph.tsx</files>
  <action>
Create EdgeNarrative modal component using Mantine Modal:

**EdgeNarrative.tsx:**
```tsx
import { Modal, Text, Stack, Badge, Skeleton, Alert } from '@mantine/core';
import { useQuery } from '@tanstack/react-query';
import { fetchNarrative } from '@/lib/api';

interface Props {
  edge: Edge | null;
  onClose: () => void;
}

export const EdgeNarrative = ({ edge, onClose }: Props) => {
  const { data, isLoading } = useQuery({
    queryKey: ['narrative', edge?.source, edge?.target],
    queryFn: () => fetchNarrative(edge!.source, edge!.target),
    enabled: !!edge
  });

  return (
    <Modal
      opened={!!edge}
      onClose={onClose}
      title="Relationship Narrative"
      size="lg"
    >
      {isLoading && <Skeleton height={200} />}

      {data && (
        <Stack gap="md">
          <Box>
            <Text fw={600} mb="xs">Connection:</Text>
            <Text size="sm">{data.entity_a.name} â†” {data.entity_b.name}</Text>
          </Box>

          <Box>
            <Text fw={600} mb="xs">Analysis:</Text>
            <Text>{data.narrative}</Text>
          </Box>

          <Box>
            <Text fw={600} mb="xs">Supporting Events ({data.events.length}):</Text>
            <Stack gap="xs">
              {data.events.map(event => (
                <Box key={event.id} p="xs" style={{ border: '1px solid var(--mantine-color-gray-3)', borderRadius: 4 }}>
                  <Text size="sm" fw={500}>{event.title}</Text>
                  <Group gap="xs" mt={4}>
                    <Badge size="sm" color="blue">{event.severity}</Badge>
                    <Badge size="sm" color="orange">Risk: {event.risk_score.toFixed(0)}</Badge>
                    <Text size="xs" c="dimmed">{new Date(event.published_at).toLocaleDateString()}</Text>
                  </Group>
                </Box>
              ))}
            </Stack>
          </Box>
        </Stack>
      )}
    </Modal>
  );
};
```

**Update EntityGraph.tsx:**
- Import EdgeNarrative component
- useState for selectedEdge
- Render EdgeNarrative at bottom with selectedEdge and onClose handler
- onEdgeClick in GraphCanvas: setSelectedEdge(edge)

Follow Phase 11 Modal pattern from Mantine. Use React Query for data fetching (Phase 10 pattern).

Don't implement "click event to view details" in this task - supporting events are just listed for verification. Navigation is future enhancement.
  </action>
  <verify>Click edge in graph, modal opens with narrative and event list, modal closable, no errors</verify>
  <done>EdgeNarrative modal shows LLM narrative when edge clicked, displays supporting events with metadata, follows Mantine UI patterns</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Camera automatically zooms to largest high-risk cluster on graph load
- [ ] Cluster nodes centered in viewport (not showing entire graph)
- [ ] NarrativeGenerator service calls Claude API successfully
- [ ] Narrative endpoint returns causal explanations
- [ ] Modal opens when edge clicked in graph
- [ ] Narrative shows 2-3 sentence causal chain
- [ ] Supporting events listed with risk/severity badges
- [ ] No API errors, modal closable
</verification>

<success_criteria>

- All tasks completed (4/4)
- All verification checks pass
- **Auto-focus:** Camera zooms to largest high-risk cluster automatically
- **Pattern discovery:** Most critical intelligence immediately visible
- **Edge narratives:** LLM explains entity connections through causal chains
- **Progressive disclosure:** Modal shows narrative with supporting events on demand
- Structured prompting following RESEARCH.md guidance
- Ready for theme filtering and lineage (Plan 26-04)
</success_criteria>

<output>
After completion, create `.planning/phases/26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking/26-03-SUMMARY.md`
</output>
