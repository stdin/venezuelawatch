---
phase: 26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking
plan: 03
type: execute
---

<objective>
Generate LLM narratives explaining entity relationships through causal event sequences.

Purpose: When users click relationship edges in the graph, show LLM-generated narrative explaining HOW and WHY entities are connected through specific events (e.g., "After sanctions on Person A, Company B filed bankruptcy, disrupting Country C trade").
Output: Working narrative generation service and modal UI showing causal stories for entity connections.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking/26-RESEARCH.md
@.planning/phases/26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking/26-CONTEXT.md
@.planning/phases/26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking/26-02-SUMMARY.md

**Phase context:**
- LLM-generated narratives explaining connections (CONTEXT.md)
- Click edge → see causal chain narrative
- Verifiable from sources - trace back to specific events

**Tech stack:**
- Anthropic Claude (claude-3-5-sonnet-20241022) - Phase 7 decision, already in project
- BigQuery for event queries (Phase 14-18 polyglot architecture)

**Research findings:**
- 2025 research shows LLMs use superficial heuristics for causal reasoning
- Must structure prompts with explicit event sequences and ask for causal relationships
- Don't use naive LLM prompting - provide event metadata (risk scores, severity, themes)
- Ask LLM to cite specific evidence from events
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create narrative generator service</name>
  <files>backend/data_pipeline/services/narrative_generator.py</files>
  <action>
Create NarrativeGenerator service using Claude API:

**generate_relationship_narrative(entity_a: Entity, entity_b: Entity, connecting_events: List[Dict]) -> str:**
- Sort connecting_events chronologically by published_at
- Build event sequence context string:
  ```
  - {date}: {title} (Risk: {risk_score}, Severity: {severity}, Themes: {themes})
  ```
- Create structured prompt:
  ```
  You are an intelligence analyst explaining how two entities are connected through events.

  Entity A: {entity_a.name} ({entity_a.entity_type})
  Entity B: {entity_b.name} ({entity_b.entity_type})

  Connecting Events (chronological):
  {event_context}

  Generate a concise causal narrative (2-3 sentences) explaining:
  1. HOW these entities are connected (direct relationship or indirect through events)
  2. WHY this relationship matters (risk implications)
  3. WHAT happened in sequence (causal chain)

  Focus on causality, not just co-occurrence. Be specific about evidence from events.
  ```
- Call Anthropic API: client.messages.create(model="claude-3-5-sonnet-20241022", max_tokens=300)
- Return generated text

**get_connecting_events(entity_a_id, entity_b_id, limit=10) helper:**
- Query BigQuery for events where both entities appear (via metadata.linked_entities)
- Return most recent events, sorted by published_at DESC
- Include: id, title, published_at, risk_score, severity, themes from GKG

Use settings.ANTHROPIC_API_KEY (already configured in Phase 7).

Don't validate narrative accuracy - that's out of scope. Trust Claude's causal reasoning with structured prompt (RESEARCH.md guidance).
  </action>
  <verify>python -c "from backend.data_pipeline.services.narrative_generator import NarrativeGenerator; ng = NarrativeGenerator(); narrative = ng.generate_relationship_narrative(entity_a, entity_b, events); print(narrative)" returns 2-3 sentence narrative without API errors</verify>
  <done>NarrativeGenerator service generates causal narratives using Claude API, prompts include event sequences and metadata, returns 2-3 sentence explanations</done>
</task>

<task type="auto">
  <name>Task 2: Add narrative API endpoint</name>
  <files>backend/api/views/graph.py</files>
  <action>
Add GET /api/graph/narrative/{entity_a_id}/{entity_b_id} to GraphRouter:

**Endpoint:**
- Path params: entity_a_id (str), entity_b_id (str)
- Fetch both Entity objects from PostgreSQL
- Call NarrativeGenerator().get_connecting_events(entity_a_id, entity_b_id)
- If no connecting events: return {narrative: "No direct connection found", events: []}
- If events exist: call generate_relationship_narrative(entity_a, entity_b, events)
- Return NarrativeResponse: {narrative: str, events: List[EventSummary], entity_a: EntityInfo, entity_b: EntityInfo}

**Response schemas:**
```python
class EventSummary(Schema):
    id: str
    title: str
    published_at: str
    risk_score: float
    severity: str

class EntityInfo(Schema):
    id: str
    name: str
    entity_type: str

class NarrativeResponse(Schema):
    narrative: str
    events: List[EventSummary]
    entity_a: EntityInfo
    entity_b: EntityInfo
```

Handle errors: 404 if entities not found, 500 if Claude API fails (log error, return generic message).

Don't cache narratives - generate fresh each time for now. Caching is performance optimization for later.
  </action>
  <verify>curl http://localhost:8000/api/graph/narrative/{id_a}/{id_b} returns JSON with narrative and event list</verify>
  <done>Narrative endpoint functional, returns LLM-generated causal explanation with supporting events, error handling for missing entities</done>
</task>

<task type="auto">
  <name>Task 3: Create EdgeNarrative modal component</name>
  <files>frontend/src/components/EntityGraph/EdgeNarrative.tsx, frontend/src/components/EntityGraph/EntityGraph.tsx</files>
  <action>
Create EdgeNarrative modal component using Mantine Modal:

**EdgeNarrative.tsx:**
```tsx
import { Modal, Text, Stack, Badge, Skeleton, Alert } from '@mantine/core';
import { useQuery } from '@tanstack/react-query';
import { fetchNarrative } from '@/lib/api';

interface Props {
  edge: Edge | null;
  onClose: () => void;
}

export const EdgeNarrative = ({ edge, onClose }: Props) => {
  const { data, isLoading } = useQuery({
    queryKey: ['narrative', edge?.source, edge?.target],
    queryFn: () => fetchNarrative(edge!.source, edge!.target),
    enabled: !!edge
  });

  return (
    <Modal
      opened={!!edge}
      onClose={onClose}
      title="Relationship Narrative"
      size="lg"
    >
      {isLoading && <Skeleton height={200} />}

      {data && (
        <Stack gap="md">
          <Box>
            <Text fw={600} mb="xs">Connection:</Text>
            <Text size="sm">{data.entity_a.name} ↔ {data.entity_b.name}</Text>
          </Box>

          <Box>
            <Text fw={600} mb="xs">Analysis:</Text>
            <Text>{data.narrative}</Text>
          </Box>

          <Box>
            <Text fw={600} mb="xs">Supporting Events ({data.events.length}):</Text>
            <Stack gap="xs">
              {data.events.map(event => (
                <Box key={event.id} p="xs" style={{ border: '1px solid var(--mantine-color-gray-3)', borderRadius: 4 }}>
                  <Text size="sm" fw={500}>{event.title}</Text>
                  <Group gap="xs" mt={4}>
                    <Badge size="sm" color="blue">{event.severity}</Badge>
                    <Badge size="sm" color="orange">Risk: {event.risk_score.toFixed(0)}</Badge>
                    <Text size="xs" c="dimmed">{new Date(event.published_at).toLocaleDateString()}</Text>
                  </Group>
                </Box>
              ))}
            </Stack>
          </Box>
        </Stack>
      )}
    </Modal>
  );
};
```

**Update EntityGraph.tsx:**
- Import EdgeNarrative component
- useState for selectedEdge
- Render EdgeNarrative at bottom with selectedEdge and onClose handler
- onEdgeClick in GraphCanvas: setSelectedEdge(edge)

Follow Phase 11 Modal pattern from Mantine. Use React Query for data fetching (Phase 10 pattern).

Don't implement "click event to view details" in this task - supporting events are just listed for verification. Navigation is future enhancement.
  </action>
  <verify>Click edge in graph, modal opens with narrative and event list, modal closable, no errors</verify>
  <done>EdgeNarrative modal shows LLM narrative when edge clicked, displays supporting events with metadata, follows Mantine UI patterns</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] NarrativeGenerator service calls Claude API successfully
- [ ] Narrative endpoint returns causal explanations
- [ ] Modal opens when edge clicked in graph
- [ ] Narrative shows 2-3 sentence causal chain
- [ ] Supporting events listed with risk/severity badges
- [ ] No API errors, modal closable
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- LLM narratives explain entity connections through causal event sequences
- Modal UI shows narrative with verifiable event sources
- Structured prompting following RESEARCH.md guidance
- Ready for GKG theme integration (Plan 26-04)
</success_criteria>

<output>
After completion, create `.planning/phases/26-gkg-theme-population-entity-relationship-graphs-event-lineage-tracking/26-03-SUMMARY.md`
</output>
